# Hello Triangle

![Cover Image](assets/cover.jpg)

A simple hello triangle example that uses all modern graphics APIs.

- üåã Vulkan

- ‚ùé DirectX 12

- ‚ùé DirectX 11

- ‚ö™ OpenGL

- ü§ñ Metal

## Setup

### Build Shader Compiler/Transpiler

First we're going to need to build our tools to compile our shader, GLSLangValidator (comes with the Vulkan SDK, but is also bundled as a submodule here) and [SPIRV-Cross](https://github.com/KhronosGroup/SPIRV-Cross).

```bash
# üî® Let's build SPIRV-Cross and GLSLangValidator to compile our shaders
# These were included in the `/external/` folder of this repo:
cd ../../external/spirv-cross
mkdir spirv-cross
cd spirv-cross
cmake ..
cmake --build . --config Release

cd ../glslangvalidator
mkdir build
cd build
cmake ..
cmake --build . --config Release

# Go to the shaders folder
cd ../../demos/hello-triangle/assets/shaders

# Make build folder
mkdir ../../build
mkdir ../../build/bin
```

### Compile Shaders

Now we can compile our shaders for the example, we'll be placing them where the final executable will be so it can read their files.

Sorry for all the going up/down folders, this is to make sure files go where they're expected:

```bash
# üåã Compile shaders to SPIR-V binary
../../../../external/glslang/build/StandAlone/Release/glslangValidator -V triangle.vert -o ../../build/bin/triangle.vert.spv
../../../../external/glslang/build/StandAlone/Release/glslangValidator -V triangle.frag -o ../../build/bin/triangle.frag.spv

# ‚ùé HLSL
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross ../../build/bin/triangle.vert.spv --hlsl --shader-model 50 --set-hlsl-vertex-input-semantic 0 POSITION --set-hlsl-vertex-input-semantic 1 COLOR --output ../../build/bin/triangle.vert.hlsl
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross ../../build/bin/triangle.frag.spv --hlsl --shader-model 50 --set-hlsl-vertex-input-semantic 0 COLOR --output ../../build/bin/triangle.frag.hlsl

# ‚ö™ OpenGL ES 3.1
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross ../../build/bin/triangle.vert.spv --version 310 --es --output ../../build/bin/triangle.vert.glsl
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross ../../build/bin/triangle.frag.spv --version 310 --es --output ../../build/bin/triangle.frag.glsl

# ü§ñ Metal
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross ../../build/bin/triangle.vert.spv --msl --output ../../build/bin/triangle.vert.msl
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross ../../build/bin/triangle.frag.spv --msl --output ../../build/bin/triangle.frag.msl
```

> Metal shader bindings don't always correspond with Vulkan shader bindings, so you'll want to change the uniform buffer location from 0 to 1 to let 0 bind to the vertex buffer.
> ```cpp
> // change buffer(0) to buffer(1)
> vertex main0_out main0(main0_in in [[stage_in]], constant UBO& ubo [[buffer(0)]])
> ```

### Compile Demo

Finally we need to build our actual example:

```bash
# üñºÔ∏è To build your Visual Studio solution on Windows x64
mkdir build
cd build
cmake .. -A x64

# üçé To build your XCode project On Mac OS for Mac OS / iOS
mkdir build
cd build
cmake .. -G Xcode

# üêß To build your .make file on Linux
mkdir build
cd build
cmake ..

# üî® Build on any platform:
cmake --build .
```
For WebAssembly you'll need to have [Emscripten](http://kripken.github.io/emscripten-site/docs/getting_started/downloads.html) installed. Assuming you have the SDK installed, do the following to build a WebAssembly project:

```bash
# üåê For WebAssembly Projects
mkdir build
cd build
cmake .. -DXWIN_OS=WASM -DCMAKE_TOOLCHAIN_FILE="$EMSDK/emscripten/1.38.1/cmake/Modules/Platform/Emscripten.cmake" -DCMAKE_BUILD_TYPE=Release

# Run emconfigure with the normal configure command as an argument.
$EMSDK/emscripten/emconfigure ./configure

# Run emmake with the normal make to generate linked LLVM bitcode.
$EMSDK/emscripten/emmake make

# Compile the linked bitcode generated by make (project.bc) to JavaScript.
#  'project.bc' should be replaced with the make output for your project (e.g. 'yourproject.so')
$EMSDK/emscripten/emcc project.bc -o project.js
```

For more information visit the [Emscripten Docs on CMake](https://kripken.github.io/emscripten-site/docs/compiling/Building-Projects.html#using-libraries).

For **Android Studio** you'll need to make a project, then edit your `build.gradle` file.

```groovy
// ü§ñ To build your Android Studio project
android {
    ...
    externalNativeBuild {
        cmake {
            ...
            // Use the following syntax when passing arguments to variables:
            // arguments "-DVAR_NAME=ARGUMENT".
            arguments "-DXWIN_PROTOCOL=ANDROID",
            // The following line passes 'rtti' and 'exceptions' to 'ANDROID_CPP_FEATURES'.
            "-DANDROID_CPP_FEATURES=rtti exceptions"
        }
    }
  buildTypes {...}

  // Use this block to link Gradle to your CMake build script.
  externalNativeBuild {
    cmake {...}
  }
}
```

## Credits

- [Sascha Willems](https://twitter.com/SaschaWillems2) - His Hello Triangle example was modified to use Vulkan's official C++ API, Sony's VectorMath, and to use CrossWindow to handle window creation.

- [Bob Brown](https://github.com/bobbrow) - For his work on the [DirectX 12 Samples](https://github.com/Microsoft/DirectX-Graphics-Samples) from which the DirectX 12 renderer is based off.

- [Matthias Moulin](https://twitter.com/matt77hias) - For his [DirectX 11 Samples](https://github.com/matt77hias/RasterTek) work for with the DirectX 11 renderer is based off of.

The OpenGL example is adapted from my [OpenGL Seed](https://github.com/alaingalvan/opengl-seed) repo showcasing how to use Qt with OpenGL.