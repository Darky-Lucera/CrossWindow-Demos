# Hello Triangle

![Cover Image](assets/cover.jpg)

A simple hello triangle example that uses all modern graphics APIs.

- 🌋 Vulkan

- ❎ DirectX 12

- ✖️ DirectX 11

- ⚪ OpenGL

- 🤖 Metal

## Setup

## Getting Started

Be sure to have the following installed:

- [CMake](https://cmake.org/)

- An IDE such as [Visual Studio](https://visualstudio.microsoft.com/downloads/), [XCode](https://developer.apple.com/xcode/), or a compiler such as [GCC](https://gcc.gnu.org/).

Then type the following in your terminal from this folder:

```bash
# 👷 Make a build folder
mkdir build
cd build

# 🖼️ To build your Visual Studio solution on Windows x64
cmake .. -A x64

# 🍎 To build your XCode project on Mac OS
cmake .. -G Xcode

# 🐧 To build your .make file on Linux
cmake ..

# 🔨 Build on any platform:
cmake --build .
```

### WebAssembly & Android

For WebAssembly you'll need to have [Emscripten](http://kripken.github.io/emscripten-site/docs/getting_started/downloads.html) installed. Assuming you have the SDK installed, do the following to build a WebAssembly project:

```bash
# 🌐 For WebAssembly Projects
mkdir build
cd build
cmake .. -DXWIN_OS=WASM -DCMAKE_TOOLCHAIN_FILE="$EMSDK/emscripten/1.38.1/cmake/Modules/Platform/Emscripten.cmake" -DCMAKE_BUILD_TYPE=Release

# Run emconfigure with the normal configure command as an argument.
$EMSDK/emscripten/emconfigure ./configure

# Run emmake with the normal make to generate linked LLVM bitcode.
$EMSDK/emscripten/emmake make

# Compile the linked bitcode generated by make (project.bc) to JavaScript.
#  'project.bc' should be replaced with the make output for your project (e.g. 'yourproject.so')
$EMSDK/emscripten/emcc project.bc -o project.js
```

For more information visit the [Emscripten Docs on CMake](https://kripken.github.io/emscripten-site/docs/compiling/Building-Projects.html#using-libraries).

For **Android Studio** you'll need to make a project, then edit your `build.gradle` file.

```groovy
// 🤖 To build your Android Studio project
android {
    ...
    externalNativeBuild {
        cmake {
            ...
            // Use the following syntax when passing arguments to variables:
            // arguments "-DVAR_NAME=ARGUMENT".
            arguments "-DXWIN_PROTOCOL=ANDROID",
            // The following line passes 'rtti' and 'exceptions' to 'ANDROID_CPP_FEATURES'.
            "-DANDROID_CPP_FEATURES=rtti exceptions"
        }
    }
  buildTypes {...}

  // Use this block to link Gradle to your CMake build script.
  externalNativeBuild {
    cmake {...}
  }
}
```

### **Optional** - Build Shader Compiler/Transpiler

If you want to edit the shaders used in this example, you'll need to compile / transpile those shaders. If not you can skip this.

First we're going to need to build our tools to compile our shader, GLSLangValidator (comes with the Vulkan SDK, but is also bundled as a submodule here) and [SPIRV-Cross](https://github.com/KhronosGroup/SPIRV-Cross).

```bash
# 🔨 Let's build SPIRV-Cross and GLSLangValidator to compile our shaders
# These were included in the `/external/` folder of this repo:
cd ../../external/spirv-cross
mkdir spirv-cross
cd spirv-cross
cmake ..
cmake --build . --config Release

cd ../glslangvalidator
mkdir build
cd build
cmake ..
cmake --build . --config Release

# Go to the shaders folder
cd ../../demos/hello-triangle/assets/shaders
```

#### Compile Shaders

Shaders are compiled already and bundled in the app, but if you want you can recompile them.

Sorry for all the going up/down folders, this is to make sure files go where they're expected:

```bash
# 🌋 Compile shaders to SPIR-V binary
../../../../external/glslang/build/StandAlone/Release/glslangValidator -V triangle.vert -o triangle.vert.spv
../../../../external/glslang/build/StandAlone/Release/glslangValidator -V triangle.frag -o triangle.frag.spv

# ❎ HLSL
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross triangle.vert.spv --hlsl --shader-model 50 --set-hlsl-vertex-input-semantic 0 POSITION --set-hlsl-vertex-input-semantic 1 COLOR --output triangle.vert.hlsl
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross triangle.frag.spv --hlsl --shader-model 50 --set-hlsl-vertex-input-semantic 0 COLOR --output triangle.frag.hlsl

# ⚪ OpenGL ES 3.1
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross .triangle.vert.spv --version 310 --es --output .triangle.vert.glsl
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross .triangle.frag.spv --version 310 --es --output .triangle.frag.glsl

# 🤖 Metal
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross .triangle.vert.spv --msl --output .triangle.vert.msl
../../../../external/spirv-cross/spirv-cross/Release/spirv-cross .triangle.frag.spv --msl --output .triangle.frag.msl
```

> Metal shader bindings don't always correspond with Vulkan shader bindings, so you'll want to change the uniform buffer location from 0 to 1 to let 0 bind to the vertex buffer.
> ```cpp
> // change buffer(0) to buffer(1)
> vertex main0_out main0(main0_in in [[stage_in]], constant UBO& ubo [[buffer(0)]])
> ```

## Credits

- [Sascha Willems](https://twitter.com/SaschaWillems2) - His Hello Triangle example was modified to use Vulkan's official C++ API, Sony's VectorMath, and to use CrossWindow to handle window creation.

- [Bob Brown](https://github.com/bobbrow) - For his work on the [DirectX 12 Samples](https://github.com/Microsoft/DirectX-Graphics-Samples) from which the DirectX 12 renderer is based off.

- [Matthias Moulin](https://twitter.com/matt77hias) - For his [DirectX 11 Samples](https://github.com/matt77hias/RasterTek) work for with the DirectX 11 renderer is based off of.

The OpenGL example is adapted from my [OpenGL Seed](https://github.com/alaingalvan/opengl-seed) repo showcasing how to use Qt with OpenGL.